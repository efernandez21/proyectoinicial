!(function(Q) {
  var U = window.webpackHotUpdate
  window.webpackHotUpdate = function(Q, F) {
    !(function(Q, U) {
      if (!C[Q] || !o[Q]) return
      for (var F in ((o[Q] = !1), U)) Object.prototype.hasOwnProperty.call(U, F) && (d[F] = U[F])
      0 == --b && 0 === L && y()
    })(Q, F),
      U && U(Q, F)
  }
  var F,
    B = !0,
    n = '2fed7f67d2287c74cba3',
    e = {},
    s = [],
    t = []
  function l(Q) {
    var U = R[Q]
    if (!U) return V
    var B = function(B) {
        return (
          U.hot.active
            ? (R[B] ? -1 === R[B].parents.indexOf(Q) && R[B].parents.push(Q) : ((s = [Q]), (F = B)),
              -1 === U.children.indexOf(B) && U.children.push(B))
            : (console.warn('[HMR] unexpected require(' + B + ') from disposed module ' + Q),
              (s = [])),
          V(B)
        )
      },
      n = function(Q) {
        return {
          configurable: !0,
          enumerable: !0,
          get: function() {
            return V[Q]
          },
          set: function(U) {
            V[Q] = U
          }
        }
      }
    for (var e in V)
      Object.prototype.hasOwnProperty.call(V, e) &&
        'e' !== e &&
        't' !== e &&
        Object.defineProperty(B, e, n(e))
    return (
      (B.e = function(Q) {
        return (
          'ready' === g && i('prepare'),
          L++,
          V.e(Q).then(U, function(Q) {
            throw (U(), Q)
          })
        )
        function U() {
          L--, 'prepare' === g && (a[Q] || G(Q), 0 === L && 0 === b && y())
        }
      }),
      (B.t = function(Q, U) {
        return 1 & U && (Q = B(Q)), V.t(Q, -2 & U)
      }),
      B
    )
  }
  function c(Q) {
    var U = {
      _acceptedDependencies: {},
      _declinedDependencies: {},
      _selfAccepted: !1,
      _selfDeclined: !1,
      _disposeHandlers: [],
      _main: F !== Q,
      active: !0,
      accept: function(Q, F) {
        if (void 0 === Q) U._selfAccepted = !0
        else if ('function' == typeof Q) U._selfAccepted = Q
        else if ('object' == typeof Q)
          for (var B = 0; B < Q.length; B++) U._acceptedDependencies[Q[B]] = F || function() {}
        else U._acceptedDependencies[Q] = F || function() {}
      },
      decline: function(Q) {
        if (void 0 === Q) U._selfDeclined = !0
        else if ('object' == typeof Q)
          for (var F = 0; F < Q.length; F++) U._declinedDependencies[Q[F]] = !0
        else U._declinedDependencies[Q] = !0
      },
      dispose: function(Q) {
        U._disposeHandlers.push(Q)
      },
      addDisposeHandler: function(Q) {
        U._disposeHandlers.push(Q)
      },
      removeDisposeHandler: function(Q) {
        var F = U._disposeHandlers.indexOf(Q)
        F >= 0 && U._disposeHandlers.splice(F, 1)
      },
      check: S,
      apply: E,
      status: function(Q) {
        if (!Q) return g
        r.push(Q)
      },
      addStatusHandler: function(Q) {
        r.push(Q)
      },
      removeStatusHandler: function(Q) {
        var U = r.indexOf(Q)
        U >= 0 && r.splice(U, 1)
      },
      data: e[Q]
    }
    return (F = void 0), U
  }
  var r = [],
    g = 'idle'
  function i(Q) {
    g = Q
    for (var U = 0; U < r.length; U++) r[U].call(null, Q)
  }
  var x,
    d,
    I,
    b = 0,
    L = 0,
    a = {},
    o = {},
    C = {}
  function u(Q) {
    return +Q + '' === Q ? +Q : Q
  }
  function S(Q) {
    if ('idle' !== g) throw new Error('check() is only allowed in idle status')
    return (
      (B = Q),
      i('check'),
      ((U = 1e4),
      (U = U || 1e4),
      new Promise(function(Q, F) {
        if ('undefined' == typeof XMLHttpRequest) return F(new Error('No browser support'))
        try {
          var B = new XMLHttpRequest(),
            e = V.p + '' + n + '.hot-update.json'
          B.open('GET', e, !0), (B.timeout = U), B.send(null)
        } catch (Q) {
          return F(Q)
        }
        B.onreadystatechange = function() {
          if (4 === B.readyState)
            if (0 === B.status) F(new Error('Manifest request to ' + e + ' timed out.'))
            else if (404 === B.status) Q()
            else if (200 !== B.status && 304 !== B.status)
              F(new Error('Manifest request to ' + e + ' failed.'))
            else {
              try {
                var U = JSON.parse(B.responseText)
              } catch (Q) {
                return void F(Q)
              }
              Q(U)
            }
        }
      })).then(function(Q) {
        if (!Q) return i('idle'), null
        ;(o = {}), (a = {}), (C = Q.c), (I = Q.h), i('prepare')
        var U = new Promise(function(Q, U) {
          x = { resolve: Q, reject: U }
        })
        d = {}
        return G(1), 'prepare' === g && 0 === L && 0 === b && y(), U
      })
    )
    var U
  }
  function G(Q) {
    C[Q]
      ? ((o[Q] = !0),
        b++,
        (function(Q) {
          var U = document.createElement('script')
          ;(U.charset = 'utf-8'),
            (U.src = V.p + '' + Q + '.' + n + '.hot-update.js'),
            document.head.appendChild(U)
        })(Q))
      : (a[Q] = !0)
  }
  function y() {
    i('ready')
    var Q = x
    if (((x = null), Q))
      if (B)
        Promise.resolve()
          .then(function() {
            return E(B)
          })
          .then(
            function(U) {
              Q.resolve(U)
            },
            function(U) {
              Q.reject(U)
            }
          )
      else {
        var U = []
        for (var F in d) Object.prototype.hasOwnProperty.call(d, F) && U.push(u(F))
        Q.resolve(U)
      }
  }
  function E(U) {
    if ('ready' !== g) throw new Error('apply() is only allowed in ready status')
    var F, B, t, l, c
    function r(Q) {
      for (
        var U = [Q],
          F = {},
          B = U.map(function(Q) {
            return { chain: [Q], id: Q }
          });
        B.length > 0;

      ) {
        var n = B.pop(),
          e = n.id,
          s = n.chain
        if ((l = R[e]) && !l.hot._selfAccepted) {
          if (l.hot._selfDeclined) return { type: 'self-declined', chain: s, moduleId: e }
          if (l.hot._main) return { type: 'unaccepted', chain: s, moduleId: e }
          for (var t = 0; t < l.parents.length; t++) {
            var c = l.parents[t],
              r = R[c]
            if (r) {
              if (r.hot._declinedDependencies[e])
                return { type: 'declined', chain: s.concat([c]), moduleId: e, parentId: c }
              ;-1 === U.indexOf(c) &&
                (r.hot._acceptedDependencies[e]
                  ? (F[c] || (F[c] = []), x(F[c], [e]))
                  : (delete F[c], U.push(c), B.push({ chain: s.concat([c]), id: c })))
            }
          }
        }
      }
      return { type: 'accepted', moduleId: Q, outdatedModules: U, outdatedDependencies: F }
    }
    function x(Q, U) {
      for (var F = 0; F < U.length; F++) {
        var B = U[F]
        ;-1 === Q.indexOf(B) && Q.push(B)
      }
    }
    U = U || {}
    var b = {},
      L = [],
      a = {},
      o = function() {
        console.warn('[HMR] unexpected require(' + G.moduleId + ') to disposed module')
      }
    for (var S in d)
      if (Object.prototype.hasOwnProperty.call(d, S)) {
        var G
        c = u(S)
        var y = !1,
          E = !1,
          Z = !1,
          p = ''
        switch (
          ((G = d[S] ? r(c) : { type: 'disposed', moduleId: S }).chain &&
            (p = '\nUpdate propagation: ' + G.chain.join(' -> ')),
          G.type)
        ) {
          case 'self-declined':
            U.onDeclined && U.onDeclined(G),
              U.ignoreDeclined ||
                (y = new Error('Aborted because of self decline: ' + G.moduleId + p))
            break
          case 'declined':
            U.onDeclined && U.onDeclined(G),
              U.ignoreDeclined ||
                (y = new Error(
                  'Aborted because of declined dependency: ' + G.moduleId + ' in ' + G.parentId + p
                ))
            break
          case 'unaccepted':
            U.onUnaccepted && U.onUnaccepted(G),
              U.ignoreUnaccepted || (y = new Error('Aborted because ' + c + ' is not accepted' + p))
            break
          case 'accepted':
            U.onAccepted && U.onAccepted(G), (E = !0)
            break
          case 'disposed':
            U.onDisposed && U.onDisposed(G), (Z = !0)
            break
          default:
            throw new Error('Unexception type ' + G.type)
        }
        if (y) return i('abort'), Promise.reject(y)
        if (E)
          for (c in ((a[c] = d[c]), x(L, G.outdatedModules), G.outdatedDependencies))
            Object.prototype.hasOwnProperty.call(G.outdatedDependencies, c) &&
              (b[c] || (b[c] = []), x(b[c], G.outdatedDependencies[c]))
        Z && (x(L, [G.moduleId]), (a[c] = o))
      }
    var m,
      N = []
    for (B = 0; B < L.length; B++)
      (c = L[B]),
        R[c] &&
          R[c].hot._selfAccepted &&
          a[c] !== o &&
          N.push({ module: c, errorHandler: R[c].hot._selfAccepted })
    i('dispose'),
      Object.keys(C).forEach(function(Q) {
        !1 === C[Q] &&
          (function(Q) {
            delete installedChunks[Q]
          })(Q)
      })
    for (var W, D, A = L.slice(); A.length > 0; )
      if (((c = A.pop()), (l = R[c]))) {
        var h = {},
          X = l.hot._disposeHandlers
        for (t = 0; t < X.length; t++) (F = X[t])(h)
        for (
          e[c] = h, l.hot.active = !1, delete R[c], delete b[c], t = 0;
          t < l.children.length;
          t++
        ) {
          var v = R[l.children[t]]
          v && (m = v.parents.indexOf(c)) >= 0 && v.parents.splice(m, 1)
        }
      }
    for (c in b)
      if (Object.prototype.hasOwnProperty.call(b, c) && (l = R[c]))
        for (D = b[c], t = 0; t < D.length; t++)
          (W = D[t]), (m = l.children.indexOf(W)) >= 0 && l.children.splice(m, 1)
    for (c in (i('apply'), (n = I), a)) Object.prototype.hasOwnProperty.call(a, c) && (Q[c] = a[c])
    var H = null
    for (c in b)
      if (Object.prototype.hasOwnProperty.call(b, c) && (l = R[c])) {
        D = b[c]
        var J = []
        for (B = 0; B < D.length; B++)
          if (((W = D[B]), (F = l.hot._acceptedDependencies[W]))) {
            if (-1 !== J.indexOf(F)) continue
            J.push(F)
          }
        for (B = 0; B < J.length; B++) {
          F = J[B]
          try {
            F(D)
          } catch (Q) {
            U.onErrored &&
              U.onErrored({ type: 'accept-errored', moduleId: c, dependencyId: D[B], error: Q }),
              U.ignoreErrored || H || (H = Q)
          }
        }
      }
    for (B = 0; B < N.length; B++) {
      var M = N[B]
      ;(c = M.module), (s = [c])
      try {
        V(c)
      } catch (Q) {
        if ('function' == typeof M.errorHandler)
          try {
            M.errorHandler(Q)
          } catch (F) {
            U.onErrored &&
              U.onErrored({
                type: 'self-accept-error-handler-errored',
                moduleId: c,
                error: F,
                originalError: Q
              }),
              U.ignoreErrored || H || (H = F),
              H || (H = Q)
          }
        else
          U.onErrored && U.onErrored({ type: 'self-accept-errored', moduleId: c, error: Q }),
            U.ignoreErrored || H || (H = Q)
      }
    }
    return H
      ? (i('fail'), Promise.reject(H))
      : (i('idle'),
        new Promise(function(Q) {
          Q(L)
        }))
  }
  var R = {}
  function V(U) {
    if (R[U]) return R[U].exports
    var F = (R[U] = {
      i: U,
      l: !1,
      exports: {},
      hot: c(U),
      parents: ((t = s), (s = []), t),
      children: []
    })
    return Q[U].call(F.exports, F, F.exports, l(U)), (F.l = !0), F.exports
  }
  ;(V.m = Q),
    (V.c = R),
    (V.d = function(Q, U, F) {
      V.o(Q, U) || Object.defineProperty(Q, U, { enumerable: !0, get: F })
    }),
    (V.r = function(Q) {
      'undefined' != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(Q, Symbol.toStringTag, { value: 'Module' }),
        Object.defineProperty(Q, '__esModule', { value: !0 })
    }),
    (V.t = function(Q, U) {
      if ((1 & U && (Q = V(Q)), 8 & U)) return Q
      if (4 & U && 'object' == typeof Q && Q && Q.__esModule) return Q
      var F = Object.create(null)
      if (
        (V.r(F),
        Object.defineProperty(F, 'default', { enumerable: !0, value: Q }),
        2 & U && 'string' != typeof Q)
      )
        for (var B in Q)
          V.d(
            F,
            B,
            function(U) {
              return Q[U]
            }.bind(null, B)
          )
      return F
    }),
    (V.n = function(Q) {
      var U =
        Q && Q.__esModule
          ? function() {
              return Q.default
            }
          : function() {
              return Q
            }
      return V.d(U, 'a', U), U
    }),
    (V.o = function(Q, U) {
      return Object.prototype.hasOwnProperty.call(Q, U)
    }),
    (V.p = ''),
    (V.h = function() {
      return n
    }),
    l(3)((V.s = 3))
})([
  ,
  function(module, __webpack_exports__, __webpack_require__) {
    'use strict'
    eval(
      "\n// EXTERNAL MODULE: ./src/polyfills.js\nvar polyfills = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./src/pointers.ts\n/**\r\n * Utilites for working with multiple pointer events\r\n */\r\nfunction findEventIndex(pointers, event) {\r\n    var i = pointers.length;\r\n    while (i--) {\r\n        if (pointers[i].pointerId === event.pointerId) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nfunction addPointer(pointers, event) {\r\n    var i;\r\n    // Add touches if applicable\r\n    if (event.touches) {\r\n        i = 0;\r\n        for (var _i = 0, _a = event.touches; _i < _a.length; _i++) {\r\n            var touch = _a[_i];\r\n            touch.pointerId = i++;\r\n            addPointer(pointers, touch);\r\n        }\r\n        return;\r\n    }\r\n    i = findEventIndex(pointers, event);\r\n    // Update if already present\r\n    if (i > -1) {\r\n        pointers.splice(i, 1);\r\n    }\r\n    pointers.push(event);\r\n}\r\nfunction removePointer(pointers, event) {\r\n    // Add touches if applicable\r\n    if (event.touches) {\r\n        // Remove all touches\r\n        while (pointers.length) {\r\n            pointers.pop();\r\n        }\r\n        return;\r\n    }\r\n    var i = findEventIndex(pointers, event);\r\n    if (i > -1) {\r\n        pointers.splice(i, 1);\r\n    }\r\n}\r\n/**\r\n * Calculates a center point between\r\n * the given pointer events, for panning\r\n * with multiple pointers.\r\n */\r\nfunction getMiddle(pointers) {\r\n    // Copy to avoid changing by reference\r\n    pointers = pointers.slice(0);\r\n    var event1 = pointers.pop();\r\n    var event2;\r\n    while ((event2 = pointers.pop())) {\r\n        event1 = {\r\n            clientX: (event2.clientX - event1.clientX) / 2 + event1.clientX,\r\n            clientY: (event2.clientY - event1.clientY) / 2 + event1.clientY\r\n        };\r\n    }\r\n    return event1;\r\n}\r\n/**\r\n * Calculates the distance between two points\r\n * for pinch zooming.\r\n * Limits to the first 2\r\n */\r\nfunction getDistance(pointers) {\r\n    if (pointers.length < 2) {\r\n        return 0;\r\n    }\r\n    var event1 = pointers[0];\r\n    var event2 = pointers[1];\r\n    return Math.sqrt(Math.pow(Math.abs(event2.clientX - event1.clientX), 2) +\r\n        Math.pow(Math.abs(event2.clientY - event1.clientY), 2));\r\n}\r\n\n// CONCATENATED MODULE: ./src/events.ts\nvar events;\r\nif (typeof window.PointerEvent === 'function') {\r\n    events = {\r\n        down: 'pointerdown',\r\n        move: 'pointermove',\r\n        up: 'pointerup pointerleave pointercancel'\r\n    };\r\n}\r\nelse if (typeof window.TouchEvent === 'function') {\r\n    events = {\r\n        down: 'touchstart',\r\n        move: 'touchmove',\r\n        up: 'touchend touchcancel'\r\n    };\r\n}\r\nelse {\r\n    events = {\r\n        down: 'mousedown',\r\n        move: 'mousemove',\r\n        up: 'mouseup mouseleave'\r\n    };\r\n}\r\nfunction onPointer(event, elem, handler, eventOpts) {\r\n    events[event].split(' ').forEach(function (name) {\r\n        ;\r\n        elem.addEventListener(name, handler, eventOpts);\r\n    });\r\n}\r\nfunction destroyPointer(event, elem, handler) {\r\n    events[event].split(' ').forEach(function (name) {\r\n        ;\r\n        elem.removeEventListener(name, handler);\r\n    });\r\n}\r\n\n// CONCATENATED MODULE: ./src/css.ts\n/**\r\n * Proper prefixing for cross-browser compatibility\r\n */\r\nvar divStyle = document.createElement('div').style;\r\nvar prefixes = ['webkit', 'moz', 'ms'];\r\nvar prefixCache = {};\r\nfunction getPrefixedName(name) {\r\n    if (prefixCache[name]) {\r\n        return prefixCache[name];\r\n    }\r\n    if (name in divStyle) {\r\n        return (prefixCache[name] = name);\r\n    }\r\n    var capName = name[0].toUpperCase() + name.slice(1);\r\n    var i = prefixes.length;\r\n    while (i--) {\r\n        var prefixedName = \"\" + prefixes[i] + capName;\r\n        if (prefixedName in divStyle) {\r\n            return (prefixCache[name] = prefixedName);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Gets a style value expected to be a number\r\n */\r\nfunction getCSSNum(name, style) {\r\n    return parseFloat(style[getPrefixedName(name)]) || 0;\r\n}\r\nfunction getBoxStyle(elem, name, style) {\r\n    if (style === void 0) { style = window.getComputedStyle(elem); }\r\n    // Support: FF 68+\r\n    // Firefox requires specificity for border\r\n    var suffix = name === 'border' ? 'Width' : '';\r\n    return {\r\n        left: getCSSNum(name + \"Left\" + suffix, style),\r\n        right: getCSSNum(name + \"Right\" + suffix, style),\r\n        top: getCSSNum(name + \"Top\" + suffix, style),\r\n        bottom: getCSSNum(name + \"Bottom\" + suffix, style)\r\n    };\r\n}\r\n/**\r\n * Set a style using the properly prefixed name\r\n */\r\nfunction setStyle(elem, name, value) {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    elem.style[getPrefixedName(name)] = value;\r\n}\r\n/**\r\n * Constructs the transition from panzoom options\r\n * and takes care of prefixing the transition and transform\r\n */\r\nfunction setTransition(elem, options) {\r\n    var transform = getPrefixedName('transform');\r\n    setStyle(elem, 'transition', transform + \" \" + options.duration + \"ms \" + options.easing);\r\n}\r\n/**\r\n * Set the transform using the proper prefix\r\n */\r\nfunction setTransform(elem, _a, _) {\r\n    var x = _a.x, y = _a.y, scale = _a.scale;\r\n    setStyle(elem, 'transform', \"scale(\" + scale + \") translate(\" + x + \"px, \" + y + \"px)\");\r\n}\r\n/**\r\n * Dimensions used in containment and focal point zooming\r\n */\r\nfunction getDimensions(elem) {\r\n    var parent = elem.parentElement;\r\n    var style = window.getComputedStyle(elem);\r\n    var parentStyle = window.getComputedStyle(parent);\r\n    var rectElem = elem.getBoundingClientRect();\r\n    var rectParent = parent.getBoundingClientRect();\r\n    return {\r\n        elem: {\r\n            style: style,\r\n            width: rectElem.width,\r\n            height: rectElem.height,\r\n            top: rectElem.top,\r\n            bottom: rectElem.bottom,\r\n            left: rectElem.left,\r\n            right: rectElem.right,\r\n            margin: getBoxStyle(elem, 'margin', style),\r\n            border: getBoxStyle(elem, 'border', style)\r\n        },\r\n        parent: {\r\n            style: parentStyle,\r\n            width: rectParent.width,\r\n            height: rectParent.height,\r\n            top: rectParent.top,\r\n            bottom: rectParent.bottom,\r\n            left: rectParent.left,\r\n            right: rectParent.right,\r\n            padding: getBoxStyle(parent, 'padding', parentStyle),\r\n            border: getBoxStyle(parent, 'border', parentStyle)\r\n        }\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./src/isAttached.ts\n/**\r\n * Determine if an element is attached to the DOM\r\n * Panzoom requires this so events work properly\r\n */\r\nfunction isAttached(elem) {\r\n    var doc = elem.ownerDocument;\r\n    var parent = elem.parentElement;\r\n    return doc && parent && doc.nodeType === 9 && parent.nodeType === 1 && doc.contains(parent);\r\n}\r\n\n// CONCATENATED MODULE: ./src/isExcluded.ts\nfunction isExcluded(elem, options) {\r\n    for (var cur = elem; cur != null; cur = cur.parentElement) {\r\n        if (cur.classList.contains(options.excludeClass) || options.exclude.indexOf(cur) > -1) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\n// CONCATENATED MODULE: ./src/isSVGElement.ts\n/**\r\n * Determine if an element is SVG by checking the namespace\r\n * Exception: the <svg> element itself should be treated like HTML\r\n */\r\nvar rsvg = /^http:[\\w\\.\\/]+svg$/;\r\nfunction isSVGElement(elem) {\r\n    return rsvg.test(elem.namespaceURI) && elem.nodeName.toLowerCase() !== 'svg';\r\n}\r\n\n// CONCATENATED MODULE: ./src/shallowClone.ts\nfunction shallowClone(obj) {\r\n    var clone = {};\r\n    for (var key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n            clone[key] = obj[key];\r\n        }\r\n    }\r\n    return clone;\r\n}\r\n\n// CONCATENATED MODULE: ./src/panzoom.ts\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n/**\r\n * Panzoom for panning and zooming elements using CSS transforms\r\n * https://github.com/timmywil/panzoom\r\n *\r\n * Copyright Timmy Willison and other contributors\r\n * Released under the MIT license\r\n * https://github.com/timmywil/panzoom/blob/master/MIT-License.txt\r\n *\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar defaultOptions = {\r\n    animate: false,\r\n    cursor: 'move',\r\n    disablePan: false,\r\n    disableZoom: false,\r\n    disableXAxis: false,\r\n    disableYAxis: false,\r\n    duration: 200,\r\n    easing: 'ease-in-out',\r\n    exclude: [],\r\n    excludeClass: 'panzoom-exclude',\r\n    handleStartEvent: function (e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n    },\r\n    maxScale: 4,\r\n    minScale: 0.125,\r\n    overflow: 'hidden',\r\n    panOnlyWhenZoomed: false,\r\n    relative: false,\r\n    setTransform: setTransform,\r\n    startX: 0,\r\n    startY: 0,\r\n    startScale: 1,\r\n    step: 0.3\r\n};\r\nfunction Panzoom(elem, options) {\r\n    if (!elem) {\r\n        throw new Error('Panzoom requires an element as an argument');\r\n    }\r\n    if (elem.nodeType !== 1) {\r\n        throw new Error('Panzoom requires an element with a nodeType of 1');\r\n    }\r\n    if (!isAttached(elem)) {\r\n        throw new Error('Panzoom should be called on elements that have been attached to the DOM');\r\n    }\r\n    options = __assign(__assign({}, defaultOptions), options);\r\n    var isSVG = isSVGElement(elem);\r\n    // Set overflow on the parent\r\n    var parent = elem.parentElement;\r\n    parent.style.overflow = options.overflow;\r\n    parent.style.userSelect = 'none';\r\n    // This is important for mobile to\r\n    // prevent scrolling while panning\r\n    parent.style.touchAction = 'none';\r\n    // Set some default styles on the panzoom element\r\n    elem.style.cursor = options.cursor;\r\n    elem.style.userSelect = 'none';\r\n    elem.style.touchAction = 'none';\r\n    // The default for HTML is '50% 50%'\r\n    // The default for SVG is '0 0'\r\n    // SVG can't be changed in IE\r\n    setStyle(elem, 'transformOrigin', typeof options.origin === 'string' ? options.origin : isSVG ? '0 0' : '50% 50%');\r\n    function setOptions(opts) {\r\n        if (opts === void 0) { opts = {}; }\r\n        for (var key in opts) {\r\n            if (opts.hasOwnProperty(key)) {\r\n                options[key] = opts[key];\r\n            }\r\n        }\r\n        // Handle option side-effects\r\n        if (opts.hasOwnProperty('cursor')) {\r\n            elem.style.cursor = opts.cursor;\r\n        }\r\n        if (opts.hasOwnProperty('overflow')) {\r\n            parent.style.overflow = opts.overflow;\r\n        }\r\n        if (opts.hasOwnProperty('minScale') ||\r\n            opts.hasOwnProperty('maxScale') ||\r\n            opts.hasOwnProperty('contain')) {\r\n            setMinMax();\r\n        }\r\n        if (opts.hasOwnProperty('disablePan')) {\r\n            if (opts.disablePan) {\r\n                destroy();\r\n            }\r\n            else {\r\n                bind();\r\n            }\r\n        }\r\n    }\r\n    var x = 0;\r\n    var y = 0;\r\n    var scale = 1;\r\n    var isPanning = false;\r\n    zoom(options.startScale, { animate: false });\r\n    // Wait for scale to update\r\n    // for accurate dimensions\r\n    // to constrain initial values\r\n    setTimeout(function () {\r\n        setMinMax();\r\n        pan(options.startX, options.startY, { animate: false });\r\n    });\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    function trigger(eventName, detail, opts) {\r\n        if (opts.silent) {\r\n            return;\r\n        }\r\n        var event = new CustomEvent(eventName, { detail: detail });\r\n        elem.dispatchEvent(event);\r\n    }\r\n    function setTransformWithEvent(eventName, opts) {\r\n        var value = { x: x, y: y, scale: scale };\r\n        requestAnimationFrame(function () {\r\n            if (typeof opts.animate === 'boolean') {\r\n                if (opts.animate) {\r\n                    setTransition(elem, opts);\r\n                }\r\n                else {\r\n                    setStyle(elem, 'transition', 'none');\r\n                }\r\n            }\r\n            opts.setTransform(elem, value, opts);\r\n        });\r\n        trigger(eventName, value, opts);\r\n        trigger('panzoomchange', value, opts);\r\n        return value;\r\n    }\r\n    function setMinMax() {\r\n        if (options.contain) {\r\n            var dims = getDimensions(elem);\r\n            var parentWidth = dims.parent.width - dims.parent.border.left - dims.parent.border.right;\r\n            var parentHeight = dims.parent.height - dims.parent.border.top - dims.parent.border.bottom;\r\n            var elemWidth = dims.elem.width / scale;\r\n            var elemHeight = dims.elem.height / scale;\r\n            var elemScaledWidth = parentWidth / elemWidth;\r\n            var elemScaledHeight = parentHeight / elemHeight;\r\n            if (options.contain === 'inside') {\r\n                options.maxScale = Math.min(elemScaledWidth, elemScaledHeight);\r\n            }\r\n            else if (options.contain === 'outside') {\r\n                options.minScale = Math.max(elemScaledWidth, elemScaledHeight);\r\n            }\r\n        }\r\n    }\r\n    function constrainXY(toX, toY, toScale, panOptions) {\r\n        var opts = __assign(__assign({}, options), panOptions);\r\n        var result = { x: x, y: y, opts: opts };\r\n        if (!opts.force && (opts.disablePan || (opts.panOnlyWhenZoomed && scale === opts.startScale))) {\r\n            return result;\r\n        }\r\n        toX = parseFloat(toX);\r\n        toY = parseFloat(toY);\r\n        if (!opts.disableXAxis) {\r\n            result.x = (opts.relative ? x : 0) + toX;\r\n        }\r\n        if (!opts.disableYAxis) {\r\n            result.y = (opts.relative ? y : 0) + toY;\r\n        }\r\n        if (opts.contain === 'inside') {\r\n            var dims = getDimensions(elem);\r\n            result.x = Math.max(-dims.elem.margin.left - dims.parent.padding.left, Math.min(dims.parent.width -\r\n                dims.elem.width / toScale -\r\n                dims.parent.padding.left -\r\n                dims.elem.margin.left -\r\n                dims.parent.border.left -\r\n                dims.parent.border.right, result.x));\r\n            result.y = Math.max(-dims.elem.margin.top - dims.parent.padding.top, Math.min(dims.parent.height -\r\n                dims.elem.height / toScale -\r\n                dims.parent.padding.top -\r\n                dims.elem.margin.top -\r\n                dims.parent.border.top -\r\n                dims.parent.border.bottom, result.y));\r\n        }\r\n        else if (opts.contain === 'outside') {\r\n            var dims = getDimensions(elem);\r\n            var realWidth = dims.elem.width / scale;\r\n            var realHeight = dims.elem.height / scale;\r\n            var scaledWidth = realWidth * toScale;\r\n            var scaledHeight = realHeight * toScale;\r\n            var diffHorizontal = (scaledWidth - realWidth) / 2;\r\n            var diffVertical = (scaledHeight - realHeight) / 2;\r\n            var minX = (-(scaledWidth - dims.parent.width) -\r\n                dims.parent.padding.left -\r\n                dims.parent.border.left -\r\n                dims.parent.border.right +\r\n                diffHorizontal) /\r\n                toScale;\r\n            var maxX = (diffHorizontal - dims.parent.padding.left) / toScale;\r\n            result.x = Math.max(Math.min(result.x, maxX), minX);\r\n            var minY = (-(scaledHeight - dims.parent.height) -\r\n                dims.parent.padding.top -\r\n                dims.parent.border.top -\r\n                dims.parent.border.bottom +\r\n                diffVertical) /\r\n                toScale;\r\n            var maxY = (diffVertical - dims.parent.padding.top) / toScale;\r\n            result.y = Math.max(Math.min(result.y, maxY), minY);\r\n        }\r\n        return result;\r\n    }\r\n    function constrainScale(toScale, zoomOptions) {\r\n        var opts = __assign(__assign({}, options), zoomOptions);\r\n        var result = { scale: scale, opts: opts };\r\n        if (!opts.force && opts.disableZoom) {\r\n            return result;\r\n        }\r\n        result.scale = Math.min(Math.max(toScale, opts.minScale), opts.maxScale);\r\n        return result;\r\n    }\r\n    function pan(toX, toY, panOptions) {\r\n        var result = constrainXY(toX, toY, scale, panOptions);\r\n        var opts = result.opts;\r\n        x = result.x;\r\n        y = result.y;\r\n        return setTransformWithEvent('panzoompan', opts);\r\n    }\r\n    function zoom(toScale, zoomOptions) {\r\n        var result = constrainScale(toScale, zoomOptions);\r\n        var opts = result.opts;\r\n        if (!opts.force && opts.disableZoom) {\r\n            return;\r\n        }\r\n        toScale = result.scale;\r\n        var toX = x;\r\n        var toY = y;\r\n        if (opts.focal) {\r\n            // The difference between the point after the scale and the point before the scale\r\n            // plus the current translation after the scale\r\n            // neutralized to no scale (as the transform scale will apply to the translation)\r\n            var focal = opts.focal;\r\n            toX = (focal.x / toScale - focal.x / scale + x * toScale) / toScale;\r\n            toY = (focal.y / toScale - focal.y / scale + y * toScale) / toScale;\r\n        }\r\n        var panResult = constrainXY(toX, toY, toScale, { relative: false, force: true });\r\n        x = panResult.x;\r\n        y = panResult.y;\r\n        scale = toScale;\r\n        return setTransformWithEvent('panzoomzoom', opts);\r\n    }\r\n    function zoomInOut(isIn, zoomOptions) {\r\n        var opts = __assign(__assign(__assign({}, options), { animate: true }), zoomOptions);\r\n        return zoom(scale * Math.exp((isIn ? 1 : -1) * opts.step), opts);\r\n    }\r\n    function zoomIn(zoomOptions) {\r\n        return zoomInOut(true, zoomOptions);\r\n    }\r\n    function zoomOut(zoomOptions) {\r\n        return zoomInOut(false, zoomOptions);\r\n    }\r\n    function zoomToPoint(toScale, point, zoomOptions) {\r\n        var dims = getDimensions(elem);\r\n        // Instead of thinking of operating on the panzoom element,\r\n        // think of operating on the area inside the panzoom\r\n        // element's parent\r\n        // Subtract padding and border\r\n        var effectiveArea = {\r\n            width: dims.parent.width -\r\n                dims.parent.padding.left -\r\n                dims.parent.padding.right -\r\n                dims.parent.border.left -\r\n                dims.parent.border.right,\r\n            height: dims.parent.height -\r\n                dims.parent.padding.top -\r\n                dims.parent.padding.bottom -\r\n                dims.parent.border.top -\r\n                dims.parent.border.bottom\r\n        };\r\n        // Adjust the clientX/clientY to ignore the area\r\n        // outside the effective area\r\n        var clientX = point.clientX -\r\n            dims.parent.left -\r\n            dims.parent.padding.left -\r\n            dims.parent.border.left -\r\n            dims.elem.margin.left;\r\n        var clientY = point.clientY -\r\n            dims.parent.top -\r\n            dims.parent.padding.top -\r\n            dims.parent.border.top -\r\n            dims.elem.margin.top;\r\n        // Adjust the clientX/clientY for HTML elements,\r\n        // because they have a transform-origin of 50% 50%\r\n        if (!isSVG) {\r\n            clientX -= dims.elem.width / scale / 2;\r\n            clientY -= dims.elem.height / scale / 2;\r\n        }\r\n        // Convert the mouse point from it's position over the\r\n        // effective area before the scale to the position\r\n        // over the effective area after the scale.\r\n        var focal = {\r\n            x: (clientX / effectiveArea.width) * (effectiveArea.width * toScale),\r\n            y: (clientY / effectiveArea.height) * (effectiveArea.height * toScale)\r\n        };\r\n        return zoom(toScale, __assign(__assign({ animate: false }, zoomOptions), { focal: focal }));\r\n    }\r\n    function zoomWithWheel(event, zoomOptions) {\r\n        // Need to prevent the default here\r\n        // or it conflicts with regular page scroll\r\n        event.preventDefault();\r\n        var opts = __assign(__assign({}, options), zoomOptions);\r\n        // Normalize to deltaX in case shift modifier is used on Mac\r\n        var delta = event.deltaY === 0 && event.deltaX ? event.deltaX : event.deltaY;\r\n        var wheel = delta < 0 ? 1 : -1;\r\n        var toScale = constrainScale(scale * Math.exp((wheel * opts.step) / 3), opts).scale;\r\n        return zoomToPoint(toScale, event, opts);\r\n    }\r\n    function reset(resetOptions) {\r\n        var opts = __assign(__assign(__assign({}, options), { animate: true, force: true }), resetOptions);\r\n        scale = constrainScale(opts.startScale, opts).scale;\r\n        var panResult = constrainXY(opts.startX, opts.startY, scale, opts);\r\n        x = panResult.x;\r\n        y = panResult.y;\r\n        return setTransformWithEvent('panzoomreset', opts);\r\n    }\r\n    var origX;\r\n    var origY;\r\n    var startClientX;\r\n    var startClientY;\r\n    var startScale;\r\n    var startDistance;\r\n    var pointers = [];\r\n    function handleDown(event) {\r\n        // Don't handle this event if the target is excluded\r\n        if (isExcluded(event.target, options)) {\r\n            return;\r\n        }\r\n        addPointer(pointers, event);\r\n        isPanning = true;\r\n        options.handleStartEvent(event);\r\n        origX = x;\r\n        origY = y;\r\n        trigger('panzoomstart', { x: x, y: y, scale: scale }, options);\r\n        // This works whether there are multiple\r\n        // pointers or not\r\n        var point = getMiddle(pointers);\r\n        startClientX = point.clientX;\r\n        startClientY = point.clientY;\r\n        startScale = scale;\r\n        startDistance = getDistance(pointers);\r\n    }\r\n    function move(event) {\r\n        if (!isPanning ||\r\n            origX === undefined ||\r\n            origY === undefined ||\r\n            startClientX === undefined ||\r\n            startClientY === undefined) {\r\n            return;\r\n        }\r\n        addPointer(pointers, event);\r\n        var current = getMiddle(pointers);\r\n        if (pointers.length > 1) {\r\n            // Use the distance between the first 2 pointers\r\n            // to determine the current scale\r\n            var diff = getDistance(pointers) - startDistance;\r\n            var toScale = constrainScale((diff * options.step) / 80 + startScale).scale;\r\n            zoomToPoint(toScale, current);\r\n        }\r\n        pan(origX + (current.clientX - startClientX) / scale, origY + (current.clientY - startClientY) / scale, {\r\n            animate: false\r\n        });\r\n    }\r\n    function handleUp(event) {\r\n        // Don't call panzoomend when panning with 2 touches\r\n        // until both touches end\r\n        if (pointers.length === 1) {\r\n            trigger('panzoomend', { x: x, y: y, scale: scale }, options);\r\n        }\r\n        // Note: don't remove all pointers\r\n        // Can restart without having to reinitiate all of them\r\n        // Remove the pointer regardless of the isPanning state\r\n        removePointer(pointers, event);\r\n        if (!isPanning) {\r\n            return;\r\n        }\r\n        isPanning = false;\r\n        origX = origY = startClientX = startClientY = undefined;\r\n    }\r\n    function bind() {\r\n        onPointer('down', elem, handleDown);\r\n        onPointer('move', document, move, { passive: true });\r\n        onPointer('up', document, handleUp, { passive: true });\r\n    }\r\n    function destroy() {\r\n        destroyPointer('down', elem, handleDown);\r\n        destroyPointer('move', document, move);\r\n        destroyPointer('up', document, handleUp);\r\n    }\r\n    if (!options.disablePan) {\r\n        bind();\r\n    }\r\n    return {\r\n        destroy: destroy,\r\n        getPan: function () { return ({ x: x, y: y }); },\r\n        getScale: function () { return scale; },\r\n        getOptions: function () { return shallowClone(options); },\r\n        pan: pan,\r\n        reset: reset,\r\n        setOptions: setOptions,\r\n        setStyle: function (name, value) { return setStyle(elem, name, value); },\r\n        zoom: zoom,\r\n        zoomIn: zoomIn,\r\n        zoomOut: zoomOut,\r\n        zoomToPoint: zoomToPoint,\r\n        zoomWithWheel: zoomWithWheel\r\n    };\r\n}\r\nPanzoom.defaultOptions = defaultOptions;\r\n/* harmony default export */ var panzoom = __webpack_exports__[\"a\"] = (Panzoom);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcG9pbnRlcnMudHM/ZDA1OCIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzLnRzPzA1ZDEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Nzcy50cz84MTQzIiwid2VicGFjazovLy8uL3NyYy9pc0F0dGFjaGVkLnRzP2EwM2IiLCJ3ZWJwYWNrOi8vLy4vc3JjL2lzRXhjbHVkZWQudHM/NTQzMiIsIndlYnBhY2s6Ly8vLi9zcmMvaXNTVkdFbGVtZW50LnRzPzQ2MjgiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYWxsb3dDbG9uZS50cz9lNDc2Iiwid2VicGFjazovLy8uL3NyYy9wYW56b29tLnRzP2I4ZjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7R0FFRztBQUVILFNBQVMsY0FBYyxDQUFDLFFBQXdCLEVBQUUsS0FBbUI7SUFDbkUsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU07SUFDdkIsT0FBTyxDQUFDLEVBQUUsRUFBRTtRQUNWLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsS0FBSyxLQUFLLENBQUMsU0FBUyxFQUFFO1lBQzdDLE9BQU8sQ0FBQztTQUNUO0tBQ0Y7SUFDRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFFTSxTQUFTLFVBQVUsQ0FBQyxRQUF3QixFQUFFLEtBQW1CO0lBQ3RFLElBQUksQ0FBQztJQUNMLDRCQUE0QjtJQUM1QixJQUFLLEtBQWEsQ0FBQyxPQUFPLEVBQUU7UUFDMUIsQ0FBQyxHQUFHLENBQUM7UUFDTCxLQUFvQixVQUFzQixFQUF0QixLQUFDLEtBQWEsQ0FBQyxPQUFPLEVBQXRCLGNBQXNCLEVBQXRCLElBQXNCLEVBQUU7WUFBdkMsSUFBTSxLQUFLO1lBQ2QsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUU7WUFDckIsVUFBVSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUM7U0FDNUI7UUFDRCxPQUFNO0tBQ1A7SUFDRCxDQUFDLEdBQUcsY0FBYyxDQUFDLFFB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Q2QsY0FBYyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxDQUFDO1FBQ3hDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQztRQUN0QyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUM7SUFDMUMsQ0FBQztJQUVELElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFO1FBQ3ZCLElBQUksRUFBRTtLQUNQO0lBRUQsT0FBTztRQUNMLE9BQU87UUFDUCxNQUFNLEVBQUUsY0FBTSxRQUFDLEVBQUUsQ0FBQyxLQUFFLENBQUMsS0FBRSxDQUFDLEVBQVYsQ0FBVTtRQUN4QixRQUFRLEVBQUUsY0FBTSxZQUFLLEVBQUwsQ0FBSztRQUNyQixVQUFVLEVBQUUsY0FBTSxtQkFBWSxDQUFDLE9BQU8sQ0FBQyxFQUFyQixDQUFxQjtRQUN2QyxHQUFHO1FBQ0gsS0FBSztRQUNMLFVBQVU7UUFDVixRQUFRLEVBQUUsVUFBQyxJQUFZLEVBQUUsS0FBYSxJQUFLLGVBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUEzQixDQUEyQjtRQUN0RSxJQUFJO1FBQ0osTUFBTTtRQUNOLE9BQU87UUFDUCxXQUFXO1FBQ1gsYUFBYTtLQUNkO0FBQ0gsQ0FBQztBQUVELE9BQU8sQ0FBQyxjQUFjLEdBQUcsY0FBYztBQUV4Qiw4RUFBTyIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXRlcyBmb3Igd29ya2luZyB3aXRoIG11bHRpcGxlIHBvaW50ZXIgZXZlbnRzXG4gKi9cblxuZnVuY3Rpb24gZmluZEV2ZW50SW5kZXgocG9pbnRlcnM6IFBvaW50ZXJFdmVudFtdLCBldmVudDogUG9pbnRlckV2ZW50KSB7XG4gIGxldCBpID0gcG9pbnRlcnMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocG9pbnRlcnNbaV0ucG9pbnRlcklkID09PSBldmVudC5wb2ludGVySWQpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUG9pbnRlcihwb2ludGVyczogUG9pbnRlckV2ZW50W10sIGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgbGV0IGlcbiAgLy8gQWRkIHRvdWNoZXMgaWYgYXBwbGljYWJsZVxuICBpZiAoKGV2ZW50IGFzIGFueSkudG91Y2hlcykge1xuICAgIGkgPSAwXG4gICAgZm9yIChjb25zdCB0b3VjaCBvZiAoZXZlbnQgYXMgYW55KS50b3VjaGVzKSB7XG4gICAgICB0b3VjaC5wb2ludGVySWQgPSBpKytcbiAgICAgIGFkZFBvaW50ZXIocG9pbnRlcnMsIHRvdWNoKVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBpID0gZmluZEV2ZW50SW5kZXgocG9pbnRlcnMsIGV2ZW50KVxuICAvLyBVcGRhdGUgaWYgYWxyZWFkeSBwcmVzZW50XG4gIGlmIChpID4gLTEpIHtcbiAgICBwb2ludGVycy5zcGxpY2UoaSwgMSlcbiAgfVxuICBwb2ludGVycy5wdXNoKGV2ZW50KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlcihwb2ludGVyczogUG9pbnRlckV2ZW50W10sIGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgLy8gQWRkIHRvdWNoZXMgaWYgYXBwbGljYWJsZVxuICBpZiAoKGV2ZW50IGFzIGFueSkudG91Y2hlcykge1xuICAgIC8vIFJlbW92ZSBhbGwgdG91Y2hlc1xuICAgIHdoaWxlIChwb2ludGVycy5sZW5ndGgpIHtcbiAgICAgIHBvaW50ZXJzLnBvcCgpXG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGkgPSBmaW5kRXZlbnRJbmRleChwb2ludGVycywgZXZlbnQpXG4gIGlmIChpID4gLTEpIHtcbiAgICBwb2ludGVycy5zcGxpY2UoaSwgMSlcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSBjZW50ZXIgcG9pbnQgYmV0d2VlblxuICogdGhlIGdpdmVuIHBvaW50ZXIgZXZlbnRzLCBmb3IgcGFubmluZ1xuICogd2l0aCBtdWx0aXBsZSBwb2ludGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pZGRsZShwb2ludGVyczogUG9pbnRlckV2ZW50W10pIHtcbiAgLy8gQ29weSB0byBhdm9pZCBjaGFuZ2luZyBieSByZWZlcmVuY2VcbiAgcG9pbnRlcnMgPSBwb2ludGVycy5zbGljZSgwKVxuICBsZXQgZXZlbnQxOiBQaWNrPFBvaW50ZXJFdmVudCwgJ2NsaWVudFgnIHwgJ2NsaWVudFknPiA9IHBvaW50ZXJzLnBvcCgpXG4gIGxldCBldmVudDI6IFBvaW50ZXJFdmVudFxuICB3aGlsZSAoKGV2ZW50MiA9IHBvaW50ZXJzLnBvcCgpKSkge1xuICAgIGV2ZW50MSA9IHtcbiAgICAgIGNsaWVudFg6IChldmVudDIuY2xpZW50WCAtIGV2ZW50MS5jbGllbnRYKSAvIDIgKyBldmVudDEuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IChldmVudDIuY2xpZW50WSAtIGV2ZW50MS5jbGllbnRZKSAvIDIgKyBldmVudDEuY2xpZW50WVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnQxXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBmb3IgcGluY2ggem9vbWluZy5cbiAqIExpbWl0cyB0byB0aGUgZmlyc3QgMlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdGFuY2UocG9pbnRlcnM6IFBvaW50ZXJFdmVudFtdKSB7XG4gIGlmIChwb2ludGVycy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBjb25zdCBldmVudDEgPSBwb2ludGVyc1swXVxuICBjb25zdCBldmVudDIgPSBwb2ludGVyc1sxXVxuICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgIE1hdGgucG93KE1hdGguYWJzKGV2ZW50Mi5jbGllbnRYIC0gZXZlbnQxLmNsaWVudFgpLCAyKSArXG4gICAgICBNYXRoLnBvdyhNYXRoLmFicyhldmVudDIuY2xpZW50WSAtIGV2ZW50MS5jbGllbnRZKSwgMilcbiAgKVxufVxuIiwibGV0IGV2ZW50czogeyBkb3duOiBzdHJpbmc7IG1vdmU6IHN0cmluZzsgdXA6IHN0cmluZyB9XG5pZiAodHlwZW9mICh3aW5kb3cgYXMgYW55KS5Qb2ludGVyRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgZXZlbnRzID0ge1xuICAgIGRvd246ICdwb2ludGVyZG93bicsXG4gICAgbW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgICB1cDogJ3BvaW50ZXJ1cCBwb2ludGVybGVhdmUgcG9pbnRlcmNhbmNlbCdcbiAgfVxufSBlbHNlIGlmICh0eXBlb2YgKHdpbmRvdyBhcyBhbnkpLlRvdWNoRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgZXZlbnRzID0ge1xuICAgIGRvd246ICd0b3VjaHN0YXJ0JyxcbiAgICBtb3ZlOiAndG91Y2htb3ZlJyxcbiAgICB1cDogJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJ1xuICB9XG59IGVsc2Uge1xuICBldmVudHMgPSB7XG4gICAgZG93bjogJ21vdXNlZG93bicsXG4gICAgbW92ZTogJ21vdXNlbW92ZScsXG4gICAgdXA6ICdtb3VzZXVwIG1vdXNlbGVhdmUnXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uUG9pbnRlcihcbiAgZXZlbnQ6ICdkb3duJyB8ICdtb3ZlJyB8ICd1cCcsXG4gIGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCB8IERvY3VtZW50LFxuICBoYW5kbGVyOiAoZXZlbnQ6IFBvaW50ZXJFdmVudCkgPT4gdm9pZCxcbiAgZXZlbnRPcHRzPzogYW55XG4pIHtcbiAgZXZlbnRzW2V2ZW50XS5zcGxpdCgnICcpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICA7KGVsZW0gYXMgSFRNTEVsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXI8XG4gICAgICAncG9pbnRlcmRvd24nIHwgJ3BvaW50ZXJtb3ZlJyB8ICdwb2ludGVydXAnIHwgJ3BvaW50ZXJsZWF2ZScgfCAncG9pbnRlcmNhbmNlbCdcbiAgICA+KG5hbWUgYXMgYW55LCBoYW5kbGVyLCBldmVudE9wdHMpXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95UG9pbnRlcihcbiAgZXZlbnQ6ICdkb3duJyB8ICdtb3ZlJyB8ICd1cCcsXG4gIGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCB8IERvY3VtZW50LFxuICBoYW5kbGVyOiAoZXZlbnQ6IFBvaW50ZXJFdmVudCkgPT4gdm9pZFxuKSB7XG4gIGV2ZW50c1tldmVudF0uc3BsaXQoJyAnKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgOyhlbGVtIGFzIEhUTUxFbGVtZW50KS5yZW1vdmVFdmVudExpc3RlbmVyPFxuICAgICAgJ3BvaW50ZXJkb3duJyB8ICdwb2ludGVybW92ZScgfCAncG9pbnRlcnVwJyB8ICdwb2ludGVybGVhdmUnIHwgJ3BvaW50ZXJjYW5jZWwnXG4gICAgPihuYW1lIGFzIGFueSwgaGFuZGxlcilcbiAgfSlcbn1cbiIsImltcG9ydCB7IEN1cnJlbnRWYWx1ZXMsIFBhbnpvb21PcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuLyoqXG4gKiBQcm9wZXIgcHJlZml4aW5nIGZvciBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHlcbiAqL1xuY29uc3QgZGl2U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZVxuY29uc3QgcHJlZml4ZXMgPSBbJ3dlYmtpdCcsICdtb3onLCAnbXMnXVxuY29uc3QgcHJlZml4Q2FjaGU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuZnVuY3Rpb24gZ2V0UHJlZml4ZWROYW1lKG5hbWU6IHN0cmluZykge1xuICBpZiAocHJlZml4Q2FjaGVbbmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4Q2FjaGVbbmFtZV1cbiAgfVxuICBpZiAobmFtZSBpbiBkaXZTdHlsZSkge1xuICAgIHJldHVybiAocHJlZml4Q2FjaGVbbmFtZV0gPSBuYW1lKVxuICB9XG4gIGNvbnN0IGNhcE5hbWUgPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpXG4gIGxldCBpID0gcHJlZml4ZXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBwcmVmaXhlZE5hbWUgPSBgJHtwcmVmaXhlc1tpXX0ke2NhcE5hbWV9YFxuICAgIGlmIChwcmVmaXhlZE5hbWUgaW4gZGl2U3R5bGUpIHtcbiAgICAgIHJldHVybiAocHJlZml4Q2FjaGVbbmFtZV0gPSBwcmVmaXhlZE5hbWUpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0cyBhIHN0eWxlIHZhbHVlIGV4cGVjdGVkIHRvIGJlIGEgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDU1NOdW0obmFtZTogc3RyaW5nLCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbikge1xuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZVtnZXRQcmVmaXhlZE5hbWUobmFtZSkgYXMgYW55XSkgfHwgMFxufVxuXG5mdW5jdGlvbiBnZXRCb3hTdHlsZShcbiAgZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LFxuICBuYW1lOiBzdHJpbmcsXG4gIHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSlcbikge1xuICAvLyBTdXBwb3J0OiBGRiA2OCtcbiAgLy8gRmlyZWZveCByZXF1aXJlcyBzcGVjaWZpY2l0eSBmb3IgYm9yZGVyXG4gIGNvbnN0IHN1ZmZpeCA9IG5hbWUgPT09ICdib3JkZXInID8gJ1dpZHRoJyA6ICcnXG4gIHJldHVybiB7XG4gICAgbGVmdDogZ2V0Q1NTTnVtKGAke25hbWV9TGVmdCR7c3VmZml4fWAsIHN0eWxlKSxcbiAgICByaWdodDogZ2V0Q1NTTnVtKGAke25hbWV9UmlnaHQke3N1ZmZpeH1gLCBzdHlsZSksXG4gICAgdG9wOiBnZXRDU1NOdW0oYCR7bmFtZX1Ub3Ake3N1ZmZpeH1gLCBzdHlsZSksXG4gICAgYm90dG9tOiBnZXRDU1NOdW0oYCR7bmFtZX1Cb3R0b20ke3N1ZmZpeH1gLCBzdHlsZSlcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHN0eWxlIHVzaW5nIHRoZSBwcm9wZXJseSBwcmVmaXhlZCBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRTdHlsZShlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBlbGVtLnN0eWxlW2dldFByZWZpeGVkTmFtZShuYW1lKSBhcyBhbnldID0gdmFsdWVcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIHRoZSB0cmFuc2l0aW9uIGZyb20gcGFuem9vbSBvcHRpb25zXG4gKiBhbmQgdGFrZXMgY2FyZSBvZiBwcmVmaXhpbmcgdGhlIHRyYW5zaXRpb24gYW5kIHRyYW5zZm9ybVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNpdGlvbihlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIG9wdGlvbnM6IFBhbnpvb21PcHRpb25zKSB7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IGdldFByZWZpeGVkTmFtZSgndHJhbnNmb3JtJylcbiAgc2V0U3R5bGUoZWxlbSwgJ3RyYW5zaXRpb24nLCBgJHt0cmFuc2Zvcm19ICR7b3B0aW9ucy5kdXJhdGlvbn1tcyAke29wdGlvbnMuZWFzaW5nfWApXG59XG5cbi8qKlxuICogU2V0IHRoZSB0cmFuc2Zvcm0gdXNpbmcgdGhlIHByb3BlciBwcmVmaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFRyYW5zZm9ybShcbiAgZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LFxuICB7IHgsIHksIHNjYWxlIH06IEN1cnJlbnRWYWx1ZXMsXG4gIF8/OiBQYW56b29tT3B0aW9uc1xuKSB7XG4gIHNldFN0eWxlKGVsZW0sICd0cmFuc2Zvcm0nLCBgc2NhbGUoJHtzY2FsZX0pIHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weClgKVxufVxuXG4vKipcbiAqIERpbWVuc2lvbnMgdXNlZCBpbiBjb250YWlubWVudCBhbmQgZm9jYWwgcG9pbnQgem9vbWluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQpIHtcbiAgY29uc3QgcGFyZW50ID0gZWxlbS5wYXJlbnRFbGVtZW50XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSlcbiAgY29uc3QgcGFyZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpXG4gIGNvbnN0IHJlY3RFbGVtID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBjb25zdCByZWN0UGFyZW50ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgcmV0dXJuIHtcbiAgICBlbGVtOiB7XG4gICAgICBzdHlsZSxcbiAgICAgIHdpZHRoOiByZWN0RWxlbS53aWR0aCxcbiAgICAgIGhlaWdodDogcmVjdEVsZW0uaGVpZ2h0LFxuICAgICAgdG9wOiByZWN0RWxlbS50b3AsXG4gICAgICBib3R0b206IHJlY3RFbGVtLmJvdHRvbSxcbiAgICAgIGxlZnQ6IHJlY3RFbGVtLmxlZnQsXG4gICAgICByaWdodDogcmVjdEVsZW0ucmlnaHQsXG4gICAgICBtYXJnaW46IGdldEJveFN0eWxlKGVsZW0sICdtYXJnaW4nLCBzdHlsZSksXG4gICAgICBib3JkZXI6IGdldEJveFN0eWxlKGVsZW0sICdib3JkZXInLCBzdHlsZSlcbiAgICB9LFxuICAgIHBhcmVudDoge1xuICAgICAgc3R5bGU6IHBhcmVudFN0eWxlLFxuICAgICAgd2lkdGg6IHJlY3RQYXJlbnQud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3RQYXJlbnQuaGVpZ2h0LFxuICAgICAgdG9wOiByZWN0UGFyZW50LnRvcCxcbiAgICAgIGJvdHRvbTogcmVjdFBhcmVudC5ib3R0b20sXG4gICAgICBsZWZ0OiByZWN0UGFyZW50LmxlZnQsXG4gICAgICByaWdodDogcmVjdFBhcmVudC5yaWdodCxcbiAgICAgIHBhZGRpbmc6IGdldEJveFN0eWxlKHBhcmVudCwgJ3BhZGRpbmcnLCBwYXJlbnRTdHlsZSksXG4gICAgICBib3JkZXI6IGdldEJveFN0eWxlKHBhcmVudCwgJ2JvcmRlcicsIHBhcmVudFN0eWxlKVxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NXG4gKiBQYW56b29tIHJlcXVpcmVzIHRoaXMgc28gZXZlbnRzIHdvcmsgcHJvcGVybHlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBdHRhY2hlZChlbGVtOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQpIHtcbiAgY29uc3QgZG9jID0gZWxlbS5vd25lckRvY3VtZW50XG4gIGNvbnN0IHBhcmVudCA9IGVsZW0ucGFyZW50RWxlbWVudFxuICByZXR1cm4gZG9jICYmIHBhcmVudCAmJiBkb2Mubm9kZVR5cGUgPT09IDkgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxICYmIGRvYy5jb250YWlucyhwYXJlbnQpXG59XG4iLCJpbXBvcnQgeyBQYW56b29tT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzRXhjbHVkZWQoZWxlbTogRWxlbWVudCwgb3B0aW9uczogUGFuem9vbU9wdGlvbnMpIHtcbiAgZm9yIChsZXQgY3VyID0gZWxlbTsgY3VyICE9IG51bGw7IGN1ciA9IGN1ci5wYXJlbnRFbGVtZW50KSB7XG4gICAgaWYgKGN1ci5jbGFzc0xpc3QuY29udGFpbnMob3B0aW9ucy5leGNsdWRlQ2xhc3MpIHx8IG9wdGlvbnMuZXhjbHVkZS5pbmRleE9mKGN1cikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCIvKipcbiAqIERldGVybWluZSBpZiBhbiBlbGVtZW50IGlzIFNWRyBieSBjaGVja2luZyB0aGUgbmFtZXNwYWNlXG4gKiBFeGNlcHRpb246IHRoZSA8c3ZnPiBlbGVtZW50IGl0c2VsZiBzaG91bGQgYmUgdHJlYXRlZCBsaWtlIEhUTUxcbiAqL1xuY29uc3QgcnN2ZyA9IC9eaHR0cDpbXFx3XFwuXFwvXStzdmckL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTVkdFbGVtZW50KGVsZW06IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCkge1xuICByZXR1cm4gcnN2Zy50ZXN0KGVsZW0ubmFtZXNwYWNlVVJJKSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdzdmcnXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzaGFsbG93Q2xvbmUob2JqOiBhbnkpIHtcbiAgY29uc3QgY2xvbmU6IGFueSA9IHt9XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY2xvbmVba2V5XSA9IG9ialtrZXldXG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZVxufVxuIiwiLyoqXG4gKiBQYW56b29tIGZvciBwYW5uaW5nIGFuZCB6b29taW5nIGVsZW1lbnRzIHVzaW5nIENTUyB0cmFuc2Zvcm1zXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdGltbXl3aWwvcGFuem9vbVxuICpcbiAqIENvcHlyaWdodCBUaW1teSBXaWxsaXNvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1teXdpbC9wYW56b29tL2Jsb2IvbWFzdGVyL01JVC1MaWNlbnNlLnR4dFxuICpcbiAqL1xuaW1wb3J0ICcuL3BvbHlmaWxscydcblxuaW1wb3J0IHsgUGFuT3B0aW9ucywgUGFuem9vbUV2ZW50LCBQYW56b29tT2JqZWN0LCBQYW56b29tT3B0aW9ucywgWm9vbU9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgYWRkUG9pbnRlciwgZ2V0RGlzdGFuY2UsIGdldE1pZGRsZSwgcmVtb3ZlUG9pbnRlciB9IGZyb20gJy4vcG9pbnRlcnMnXG5pbXBvcnQgeyBkZXN0cm95UG9pbnRlciwgb25Qb2ludGVyIH0gZnJvbSAnLi9ldmVudHMnXG5pbXBvcnQgeyBnZXREaW1lbnNpb25zLCBzZXRTdHlsZSwgc2V0VHJhbnNmb3JtLCBzZXRUcmFuc2l0aW9uIH0gZnJvbSAnLi9jc3MnXG5cbmltcG9ydCBpc0F0dGFjaGVkIGZyb20gJy4vaXNBdHRhY2hlZCdcbmltcG9ydCBpc0V4Y2x1ZGVkIGZyb20gJy4vaXNFeGNsdWRlZCdcbmltcG9ydCBpc1NWR0VsZW1lbnQgZnJvbSAnLi9pc1NWR0VsZW1lbnQnXG5pbXBvcnQgc2hhbGxvd0Nsb25lIGZyb20gJy4vc2hhbGxvd0Nsb25lJ1xuXG5jb25zdCBkZWZhdWx0T3B0aW9uczogUGFuem9vbU9wdGlvbnMgPSB7XG4gIGFuaW1hdGU6IGZhbHNlLFxuICBjdXJzb3I6ICdtb3ZlJyxcbiAgZGlzYWJsZVBhbjogZmFsc2UsXG4gIGRpc2FibGVab29tOiBmYWxzZSxcbiAgZGlzYWJsZVhBeGlzOiBmYWxzZSxcbiAgZGlzYWJsZVlBeGlzOiBmYWxzZSxcbiAgZHVyYXRpb246IDIwMCxcbiAgZWFzaW5nOiAnZWFzZS1pbi1vdXQnLFxuICBleGNsdWRlOiBbXSxcbiAgZXhjbHVkZUNsYXNzOiAncGFuem9vbS1leGNsdWRlJyxcbiAgaGFuZGxlU3RhcnRFdmVudDogKGU6IEV2ZW50KSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICB9LFxuICBtYXhTY2FsZTogNCxcbiAgbWluU2NhbGU6IDAuMTI1LFxuICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIHBhbk9ubHlXaGVuWm9vbWVkOiBmYWxzZSxcbiAgcmVsYXRpdmU6IGZhbHNlLFxuICBzZXRUcmFuc2Zvcm0sXG4gIHN0YXJ0WDogMCxcbiAgc3RhcnRZOiAwLFxuICBzdGFydFNjYWxlOiAxLFxuICBzdGVwOiAwLjNcbn1cblxuZnVuY3Rpb24gUGFuem9vbShcbiAgZWxlbTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LFxuICBvcHRpb25zPzogT21pdDxQYW56b29tT3B0aW9ucywgJ2ZvcmNlJz5cbik6IFBhbnpvb21PYmplY3Qge1xuICBpZiAoIWVsZW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhbnpvb20gcmVxdWlyZXMgYW4gZWxlbWVudCBhcyBhbiBhcmd1bWVudCcpXG4gIH1cbiAgaWYgKGVsZW0ubm9kZVR5cGUgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhbnpvb20gcmVxdWlyZXMgYW4gZWxlbWVudCB3aXRoIGEgbm9kZVR5cGUgb2YgMScpXG4gIH1cbiAgaWYgKCFpc0F0dGFjaGVkKGVsZW0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYW56b29tIHNob3VsZCBiZSBjYWxsZWQgb24gZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gYXR0YWNoZWQgdG8gdGhlIERPTScpXG4gIH1cblxuICBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfVxuXG4gIGNvbnN0IGlzU1ZHID0gaXNTVkdFbGVtZW50KGVsZW0pXG5cbiAgLy8gU2V0IG92ZXJmbG93IG9uIHRoZSBwYXJlbnRcbiAgY29uc3QgcGFyZW50ID0gZWxlbS5wYXJlbnRFbGVtZW50XG4gIHBhcmVudC5zdHlsZS5vdmVyZmxvdyA9IG9wdGlvbnMub3ZlcmZsb3dcbiAgcGFyZW50LnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSdcbiAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIG1vYmlsZSB0b1xuICAvLyBwcmV2ZW50IHNjcm9sbGluZyB3aGlsZSBwYW5uaW5nXG4gIHBhcmVudC5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJ1xuXG4gIC8vIFNldCBzb21lIGRlZmF1bHQgc3R5bGVzIG9uIHRoZSBwYW56b29tIGVsZW1lbnRcbiAgZWxlbS5zdHlsZS5jdXJzb3IgPSBvcHRpb25zLmN1cnNvclxuICBlbGVtLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSdcbiAgZWxlbS5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJ1xuICAvLyBUaGUgZGVmYXVsdCBmb3IgSFRNTCBpcyAnNTAlIDUwJSdcbiAgLy8gVGhlIGRlZmF1bHQgZm9yIFNWRyBpcyAnMCAwJ1xuICAvLyBTVkcgY2FuJ3QgYmUgY2hhbmdlZCBpbiBJRVxuICBzZXRTdHlsZShcbiAgICBlbGVtLFxuICAgICd0cmFuc2Zvcm1PcmlnaW4nLFxuICAgIHR5cGVvZiBvcHRpb25zLm9yaWdpbiA9PT0gJ3N0cmluZycgPyBvcHRpb25zLm9yaWdpbiA6IGlzU1ZHID8gJzAgMCcgOiAnNTAlIDUwJSdcbiAgKVxuXG4gIGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0czogT21pdDxQYW56b29tT3B0aW9ucywgJ2ZvcmNlJz4gPSB7fSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdHMpIHtcbiAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgb3B0aW9uc1trZXldID0gb3B0c1trZXldXG4gICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZSBvcHRpb24gc2lkZS1lZmZlY3RzXG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoJ2N1cnNvcicpKSB7XG4gICAgICBlbGVtLnN0eWxlLmN1cnNvciA9IG9wdHMuY3Vyc29yXG4gICAgfVxuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KCdvdmVyZmxvdycpKSB7XG4gICAgICBwYXJlbnQuc3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93XG4gICAgfVxuICAgIGlmIChcbiAgICAgIG9wdHMuaGFzT3duUHJvcGVydHkoJ21pblNjYWxlJykgfHxcbiAgICAgIG9wdHMuaGFzT3duUHJvcGVydHkoJ21heFNjYWxlJykgfHxcbiAgICAgIG9wdHMuaGFzT3duUHJvcGVydHkoJ2NvbnRhaW4nKVxuICAgICkge1xuICAgICAgc2V0TWluTWF4KClcbiAgICB9XG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoJ2Rpc2FibGVQYW4nKSkge1xuICAgICAgaWYgKG9wdHMuZGlzYWJsZVBhbikge1xuICAgICAgICBkZXN0cm95KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbmQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCB4ID0gMFxuICBsZXQgeSA9IDBcbiAgbGV0IHNjYWxlID0gMVxuICBsZXQgaXNQYW5uaW5nID0gZmFsc2VcbiAgem9vbShvcHRpb25zLnN0YXJ0U2NhbGUsIHsgYW5pbWF0ZTogZmFsc2UgfSlcbiAgLy8gV2FpdCBmb3Igc2NhbGUgdG8gdXBkYXRlXG4gIC8vIGZvciBhY2N1cmF0ZSBkaW1lbnNpb25zXG4gIC8vIHRvIGNvbnN0cmFpbiBpbml0aWFsIHZhbHVlc1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBzZXRNaW5NYXgoKVxuICAgIHBhbihvcHRpb25zLnN0YXJ0WCwgb3B0aW9ucy5zdGFydFksIHsgYW5pbWF0ZTogZmFsc2UgfSlcbiAgfSlcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50TmFtZTogUGFuem9vbUV2ZW50LCBkZXRhaWw6IGFueSwgb3B0czogUGFuem9vbU9wdGlvbnMpIHtcbiAgICBpZiAob3B0cy5zaWxlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsIH0pXG4gICAgZWxlbS5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VHJhbnNmb3JtV2l0aEV2ZW50KGV2ZW50TmFtZTogUGFuem9vbUV2ZW50LCBvcHRzOiBQYW56b29tT3B0aW9ucykge1xuICAgIGNvbnN0IHZhbHVlID0geyB4LCB5LCBzY2FsZSB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5hbmltYXRlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKG9wdHMuYW5pbWF0ZSkge1xuICAgICAgICAgIHNldFRyYW5zaXRpb24oZWxlbSwgb3B0cylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRTdHlsZShlbGVtLCAndHJhbnNpdGlvbicsICdub25lJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0cy5zZXRUcmFuc2Zvcm0oZWxlbSwgdmFsdWUsIG9wdHMpXG4gICAgfSlcbiAgICB0cmlnZ2VyKGV2ZW50TmFtZSwgdmFsdWUsIG9wdHMpXG4gICAgdHJpZ2dlcigncGFuem9vbWNoYW5nZScsIHZhbHVlLCBvcHRzKVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TWluTWF4KCkge1xuICAgIGlmIChvcHRpb25zLmNvbnRhaW4pIHtcbiAgICAgIGNvbnN0IGRpbXMgPSBnZXREaW1lbnNpb25zKGVsZW0pXG4gICAgICBjb25zdCBwYXJlbnRXaWR0aCA9IGRpbXMucGFyZW50LndpZHRoIC0gZGltcy5wYXJlbnQuYm9yZGVyLmxlZnQgLSBkaW1zLnBhcmVudC5ib3JkZXIucmlnaHRcbiAgICAgIGNvbnN0IHBhcmVudEhlaWdodCA9IGRpbXMucGFyZW50LmhlaWdodCAtIGRpbXMucGFyZW50LmJvcmRlci50b3AgLSBkaW1zLnBhcmVudC5ib3JkZXIuYm90dG9tXG4gICAgICBjb25zdCBlbGVtV2lkdGggPSBkaW1zLmVsZW0ud2lkdGggLyBzY2FsZVxuICAgICAgY29uc3QgZWxlbUhlaWdodCA9IGRpbXMuZWxlbS5oZWlnaHQgLyBzY2FsZVxuICAgICAgY29uc3QgZWxlbVNjYWxlZFdpZHRoID0gcGFyZW50V2lkdGggLyBlbGVtV2lkdGhcbiAgICAgIGNvbnN0IGVsZW1TY2FsZWRIZWlnaHQgPSBwYXJlbnRIZWlnaHQgLyBlbGVtSGVpZ2h0XG4gICAgICBpZiAob3B0aW9ucy5jb250YWluID09PSAnaW5zaWRlJykge1xuICAgICAgICBvcHRpb25zLm1heFNjYWxlID0gTWF0aC5taW4oZWxlbVNjYWxlZFdpZHRoLCBlbGVtU2NhbGVkSGVpZ2h0KVxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmNvbnRhaW4gPT09ICdvdXRzaWRlJykge1xuICAgICAgICBvcHRpb25zLm1pblNjYWxlID0gTWF0aC5tYXgoZWxlbVNjYWxlZFdpZHRoLCBlbGVtU2NhbGVkSGVpZ2h0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cmFpblhZKFxuICAgIHRvWDogbnVtYmVyIHwgc3RyaW5nLFxuICAgIHRvWTogbnVtYmVyIHwgc3RyaW5nLFxuICAgIHRvU2NhbGU6IG51bWJlcixcbiAgICBwYW5PcHRpb25zPzogUGFuT3B0aW9uc1xuICApIHtcbiAgICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zLCAuLi5wYW5PcHRpb25zIH1cbiAgICBjb25zdCByZXN1bHQgPSB7IHgsIHksIG9wdHMgfVxuICAgIGlmICghb3B0cy5mb3JjZSAmJiAob3B0cy5kaXNhYmxlUGFuIHx8IChvcHRzLnBhbk9ubHlXaGVuWm9vbWVkICYmIHNjYWxlID09PSBvcHRzLnN0YXJ0U2NhbGUpKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICB0b1ggPSBwYXJzZUZsb2F0KHRvWCBhcyBzdHJpbmcpXG4gICAgdG9ZID0gcGFyc2VGbG9hdCh0b1kgYXMgc3RyaW5nKVxuXG4gICAgaWYgKCFvcHRzLmRpc2FibGVYQXhpcykge1xuICAgICAgcmVzdWx0LnggPSAob3B0cy5yZWxhdGl2ZSA/IHggOiAwKSArIHRvWFxuICAgIH1cblxuICAgIGlmICghb3B0cy5kaXNhYmxlWUF4aXMpIHtcbiAgICAgIHJlc3VsdC55ID0gKG9wdHMucmVsYXRpdmUgPyB5IDogMCkgKyB0b1lcbiAgICB9XG5cbiAgICBpZiAob3B0cy5jb250YWluID09PSAnaW5zaWRlJykge1xuICAgICAgY29uc3QgZGltcyA9IGdldERpbWVuc2lvbnMoZWxlbSlcbiAgICAgIHJlc3VsdC54ID0gTWF0aC5tYXgoXG4gICAgICAgIC1kaW1zLmVsZW0ubWFyZ2luLmxlZnQgLSBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQsXG4gICAgICAgIE1hdGgubWluKFxuICAgICAgICAgIGRpbXMucGFyZW50LndpZHRoIC1cbiAgICAgICAgICAgIGRpbXMuZWxlbS53aWR0aCAvIHRvU2NhbGUgLVxuICAgICAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy5sZWZ0IC1cbiAgICAgICAgICAgIGRpbXMuZWxlbS5tYXJnaW4ubGVmdCAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIubGVmdCAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIucmlnaHQsXG4gICAgICAgICAgcmVzdWx0LnhcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgcmVzdWx0LnkgPSBNYXRoLm1heChcbiAgICAgICAgLWRpbXMuZWxlbS5tYXJnaW4udG9wIC0gZGltcy5wYXJlbnQucGFkZGluZy50b3AsXG4gICAgICAgIE1hdGgubWluKFxuICAgICAgICAgIGRpbXMucGFyZW50LmhlaWdodCAtXG4gICAgICAgICAgICBkaW1zLmVsZW0uaGVpZ2h0IC8gdG9TY2FsZSAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLnRvcCAtXG4gICAgICAgICAgICBkaW1zLmVsZW0ubWFyZ2luLnRvcCAtXG4gICAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIudG9wIC1cbiAgICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5ib3R0b20sXG4gICAgICAgICAgcmVzdWx0LnlcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAob3B0cy5jb250YWluID09PSAnb3V0c2lkZScpIHtcbiAgICAgIGNvbnN0IGRpbXMgPSBnZXREaW1lbnNpb25zKGVsZW0pXG4gICAgICBjb25zdCByZWFsV2lkdGggPSBkaW1zLmVsZW0ud2lkdGggLyBzY2FsZVxuICAgICAgY29uc3QgcmVhbEhlaWdodCA9IGRpbXMuZWxlbS5oZWlnaHQgLyBzY2FsZVxuICAgICAgY29uc3Qgc2NhbGVkV2lkdGggPSByZWFsV2lkdGggKiB0b1NjYWxlXG4gICAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSByZWFsSGVpZ2h0ICogdG9TY2FsZVxuICAgICAgY29uc3QgZGlmZkhvcml6b250YWwgPSAoc2NhbGVkV2lkdGggLSByZWFsV2lkdGgpIC8gMlxuICAgICAgY29uc3QgZGlmZlZlcnRpY2FsID0gKHNjYWxlZEhlaWdodCAtIHJlYWxIZWlnaHQpIC8gMlxuICAgICAgY29uc3QgbWluWCA9XG4gICAgICAgICgtKHNjYWxlZFdpZHRoIC0gZGltcy5wYXJlbnQud2lkdGgpIC1cbiAgICAgICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQgLVxuICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5sZWZ0IC1cbiAgICAgICAgICBkaW1zLnBhcmVudC5ib3JkZXIucmlnaHQgK1xuICAgICAgICAgIGRpZmZIb3Jpem9udGFsKSAvXG4gICAgICAgIHRvU2NhbGVcbiAgICAgIGNvbnN0IG1heFggPSAoZGlmZkhvcml6b250YWwgLSBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQpIC8gdG9TY2FsZVxuICAgICAgcmVzdWx0LnggPSBNYXRoLm1heChNYXRoLm1pbihyZXN1bHQueCwgbWF4WCksIG1pblgpXG4gICAgICBjb25zdCBtaW5ZID1cbiAgICAgICAgKC0oc2NhbGVkSGVpZ2h0IC0gZGltcy5wYXJlbnQuaGVpZ2h0KSAtXG4gICAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy50b3AgLVxuICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci50b3AgLVxuICAgICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5ib3R0b20gK1xuICAgICAgICAgIGRpZmZWZXJ0aWNhbCkgL1xuICAgICAgICB0b1NjYWxlXG4gICAgICBjb25zdCBtYXhZID0gKGRpZmZWZXJ0aWNhbCAtIGRpbXMucGFyZW50LnBhZGRpbmcudG9wKSAvIHRvU2NhbGVcbiAgICAgIHJlc3VsdC55ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVzdWx0LnksIG1heFkpLCBtaW5ZKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJhaW5TY2FsZSh0b1NjYWxlOiBudW1iZXIsIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zLCAuLi56b29tT3B0aW9ucyB9XG4gICAgY29uc3QgcmVzdWx0ID0geyBzY2FsZSwgb3B0cyB9XG4gICAgaWYgKCFvcHRzLmZvcmNlICYmIG9wdHMuZGlzYWJsZVpvb20pIHtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gICAgcmVzdWx0LnNjYWxlID0gTWF0aC5taW4oTWF0aC5tYXgodG9TY2FsZSwgb3B0cy5taW5TY2FsZSksIG9wdHMubWF4U2NhbGUpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gcGFuKHRvWDogbnVtYmVyIHwgc3RyaW5nLCB0b1k6IG51bWJlciB8IHN0cmluZywgcGFuT3B0aW9ucz86IFBhbk9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjb25zdHJhaW5YWSh0b1gsIHRvWSwgc2NhbGUsIHBhbk9wdGlvbnMpXG4gICAgY29uc3Qgb3B0cyA9IHJlc3VsdC5vcHRzXG5cbiAgICB4ID0gcmVzdWx0LnhcbiAgICB5ID0gcmVzdWx0LnlcblxuICAgIHJldHVybiBzZXRUcmFuc2Zvcm1XaXRoRXZlbnQoJ3Bhbnpvb21wYW4nLCBvcHRzKVxuICB9XG5cbiAgZnVuY3Rpb24gem9vbSh0b1NjYWxlOiBudW1iZXIsIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjb25zdHJhaW5TY2FsZSh0b1NjYWxlLCB6b29tT3B0aW9ucylcbiAgICBjb25zdCBvcHRzID0gcmVzdWx0Lm9wdHNcbiAgICBpZiAoIW9wdHMuZm9yY2UgJiYgb3B0cy5kaXNhYmxlWm9vbSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRvU2NhbGUgPSByZXN1bHQuc2NhbGVcbiAgICBsZXQgdG9YID0geFxuICAgIGxldCB0b1kgPSB5XG5cbiAgICBpZiAob3B0cy5mb2NhbCkge1xuICAgICAgLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9pbnQgYWZ0ZXIgdGhlIHNjYWxlIGFuZCB0aGUgcG9pbnQgYmVmb3JlIHRoZSBzY2FsZVxuICAgICAgLy8gcGx1cyB0aGUgY3VycmVudCB0cmFuc2xhdGlvbiBhZnRlciB0aGUgc2NhbGVcbiAgICAgIC8vIG5ldXRyYWxpemVkIHRvIG5vIHNjYWxlIChhcyB0aGUgdHJhbnNmb3JtIHNjYWxlIHdpbGwgYXBwbHkgdG8gdGhlIHRyYW5zbGF0aW9uKVxuICAgICAgY29uc3QgZm9jYWwgPSBvcHRzLmZvY2FsXG4gICAgICB0b1ggPSAoZm9jYWwueCAvIHRvU2NhbGUgLSBmb2NhbC54IC8gc2NhbGUgKyB4ICogdG9TY2FsZSkgLyB0b1NjYWxlXG4gICAgICB0b1kgPSAoZm9jYWwueSAvIHRvU2NhbGUgLSBmb2NhbC55IC8gc2NhbGUgKyB5ICogdG9TY2FsZSkgLyB0b1NjYWxlXG4gICAgfVxuICAgIGNvbnN0IHBhblJlc3VsdCA9IGNvbnN0cmFpblhZKHRvWCwgdG9ZLCB0b1NjYWxlLCB7IHJlbGF0aXZlOiBmYWxzZSwgZm9yY2U6IHRydWUgfSlcbiAgICB4ID0gcGFuUmVzdWx0LnhcbiAgICB5ID0gcGFuUmVzdWx0LnlcbiAgICBzY2FsZSA9IHRvU2NhbGVcbiAgICByZXR1cm4gc2V0VHJhbnNmb3JtV2l0aEV2ZW50KCdwYW56b29tem9vbScsIG9wdHMpXG4gIH1cblxuICBmdW5jdGlvbiB6b29tSW5PdXQoaXNJbjogYm9vbGVhbiwgem9vbU9wdGlvbnM/OiBab29tT3B0aW9ucykge1xuICAgIGNvbnN0IG9wdHMgPSB7IC4uLm9wdGlvbnMsIGFuaW1hdGU6IHRydWUsIC4uLnpvb21PcHRpb25zIH1cbiAgICByZXR1cm4gem9vbShzY2FsZSAqIE1hdGguZXhwKChpc0luID8gMSA6IC0xKSAqIG9wdHMuc3RlcCksIG9wdHMpXG4gIH1cblxuICBmdW5jdGlvbiB6b29tSW4oem9vbU9wdGlvbnM/OiBab29tT3B0aW9ucykge1xuICAgIHJldHVybiB6b29tSW5PdXQodHJ1ZSwgem9vbU9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiB6b29tT3V0KHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICByZXR1cm4gem9vbUluT3V0KGZhbHNlLCB6b29tT3B0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIHpvb21Ub1BvaW50KFxuICAgIHRvU2NhbGU6IG51bWJlcixcbiAgICBwb2ludDogeyBjbGllbnRYOiBudW1iZXI7IGNsaWVudFk6IG51bWJlciB9LFxuICAgIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgZGltcyA9IGdldERpbWVuc2lvbnMoZWxlbSlcblxuICAgIC8vIEluc3RlYWQgb2YgdGhpbmtpbmcgb2Ygb3BlcmF0aW5nIG9uIHRoZSBwYW56b29tIGVsZW1lbnQsXG4gICAgLy8gdGhpbmsgb2Ygb3BlcmF0aW5nIG9uIHRoZSBhcmVhIGluc2lkZSB0aGUgcGFuem9vbVxuICAgIC8vIGVsZW1lbnQncyBwYXJlbnRcbiAgICAvLyBTdWJ0cmFjdCBwYWRkaW5nIGFuZCBib3JkZXJcbiAgICBjb25zdCBlZmZlY3RpdmVBcmVhID0ge1xuICAgICAgd2lkdGg6XG4gICAgICAgIGRpbXMucGFyZW50LndpZHRoIC1cbiAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy5sZWZ0IC1cbiAgICAgICAgZGltcy5wYXJlbnQucGFkZGluZy5yaWdodCAtXG4gICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5sZWZ0IC1cbiAgICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnJpZ2h0LFxuICAgICAgaGVpZ2h0OlxuICAgICAgICBkaW1zLnBhcmVudC5oZWlnaHQgLVxuICAgICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLnRvcCAtXG4gICAgICAgIGRpbXMucGFyZW50LnBhZGRpbmcuYm90dG9tIC1cbiAgICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnRvcCAtXG4gICAgICAgIGRpbXMucGFyZW50LmJvcmRlci5ib3R0b21cbiAgICB9XG5cbiAgICAvLyBBZGp1c3QgdGhlIGNsaWVudFgvY2xpZW50WSB0byBpZ25vcmUgdGhlIGFyZWFcbiAgICAvLyBvdXRzaWRlIHRoZSBlZmZlY3RpdmUgYXJlYVxuICAgIGxldCBjbGllbnRYID1cbiAgICAgIHBvaW50LmNsaWVudFggLVxuICAgICAgZGltcy5wYXJlbnQubGVmdCAtXG4gICAgICBkaW1zLnBhcmVudC5wYWRkaW5nLmxlZnQgLVxuICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLmxlZnQgLVxuICAgICAgZGltcy5lbGVtLm1hcmdpbi5sZWZ0XG4gICAgbGV0IGNsaWVudFkgPVxuICAgICAgcG9pbnQuY2xpZW50WSAtXG4gICAgICBkaW1zLnBhcmVudC50b3AgLVxuICAgICAgZGltcy5wYXJlbnQucGFkZGluZy50b3AgLVxuICAgICAgZGltcy5wYXJlbnQuYm9yZGVyLnRvcCAtXG4gICAgICBkaW1zLmVsZW0ubWFyZ2luLnRvcFxuXG4gICAgLy8gQWRqdXN0IHRoZSBjbGllbnRYL2NsaWVudFkgZm9yIEhUTUwgZWxlbWVudHMsXG4gICAgLy8gYmVjYXVzZSB0aGV5IGhhdmUgYSB0cmFuc2Zvcm0tb3JpZ2luIG9mIDUwJSA1MCVcbiAgICBpZiAoIWlzU1ZHKSB7XG4gICAgICBjbGllbnRYIC09IGRpbXMuZWxlbS53aWR0aCAvIHNjYWxlIC8gMlxuICAgICAgY2xpZW50WSAtPSBkaW1zLmVsZW0uaGVpZ2h0IC8gc2NhbGUgLyAyXG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0aGUgbW91c2UgcG9pbnQgZnJvbSBpdCdzIHBvc2l0aW9uIG92ZXIgdGhlXG4gICAgLy8gZWZmZWN0aXZlIGFyZWEgYmVmb3JlIHRoZSBzY2FsZSB0byB0aGUgcG9zaXRpb25cbiAgICAvLyBvdmVyIHRoZSBlZmZlY3RpdmUgYXJlYSBhZnRlciB0aGUgc2NhbGUuXG4gICAgY29uc3QgZm9jYWwgPSB7XG4gICAgICB4OiAoY2xpZW50WCAvIGVmZmVjdGl2ZUFyZWEud2lkdGgpICogKGVmZmVjdGl2ZUFyZWEud2lkdGggKiB0b1NjYWxlKSxcbiAgICAgIHk6IChjbGllbnRZIC8gZWZmZWN0aXZlQXJlYS5oZWlnaHQpICogKGVmZmVjdGl2ZUFyZWEuaGVpZ2h0ICogdG9TY2FsZSlcbiAgICB9XG5cbiAgICByZXR1cm4gem9vbSh0b1NjYWxlLCB7IGFuaW1hdGU6IGZhbHNlLCAuLi56b29tT3B0aW9ucywgZm9jYWwgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHpvb21XaXRoV2hlZWwoZXZlbnQ6IFdoZWVsRXZlbnQsIHpvb21PcHRpb25zPzogWm9vbU9wdGlvbnMpIHtcbiAgICAvLyBOZWVkIHRvIHByZXZlbnQgdGhlIGRlZmF1bHQgaGVyZVxuICAgIC8vIG9yIGl0IGNvbmZsaWN0cyB3aXRoIHJlZ3VsYXIgcGFnZSBzY3JvbGxcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zLCAuLi56b29tT3B0aW9ucyB9XG5cbiAgICAvLyBOb3JtYWxpemUgdG8gZGVsdGFYIGluIGNhc2Ugc2hpZnQgbW9kaWZpZXIgaXMgdXNlZCBvbiBNYWNcbiAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRlbHRhWSA9PT0gMCAmJiBldmVudC5kZWx0YVggPyBldmVudC5kZWx0YVggOiBldmVudC5kZWx0YVlcbiAgICBjb25zdCB3aGVlbCA9IGRlbHRhIDwgMCA/IDEgOiAtMVxuICAgIGNvbnN0IHRvU2NhbGUgPSBjb25zdHJhaW5TY2FsZShzY2FsZSAqIE1hdGguZXhwKCh3aGVlbCAqIG9wdHMuc3RlcCkgLyAzKSwgb3B0cykuc2NhbGVcblxuICAgIHJldHVybiB6b29tVG9Qb2ludCh0b1NjYWxlLCBldmVudCwgb3B0cylcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0KHJlc2V0T3B0aW9ucz86IFBhbnpvb21PcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4ub3B0aW9ucywgYW5pbWF0ZTogdHJ1ZSwgZm9yY2U6IHRydWUsIC4uLnJlc2V0T3B0aW9ucyB9XG4gICAgc2NhbGUgPSBjb25zdHJhaW5TY2FsZShvcHRzLnN0YXJ0U2NhbGUsIG9wdHMpLnNjYWxlXG4gICAgY29uc3QgcGFuUmVzdWx0ID0gY29uc3RyYWluWFkob3B0cy5zdGFydFgsIG9wdHMuc3RhcnRZLCBzY2FsZSwgb3B0cylcbiAgICB4ID0gcGFuUmVzdWx0LnhcbiAgICB5ID0gcGFuUmVzdWx0LnlcbiAgICByZXR1cm4gc2V0VHJhbnNmb3JtV2l0aEV2ZW50KCdwYW56b29tcmVzZXQnLCBvcHRzKVxuICB9XG5cbiAgbGV0IG9yaWdYOiBudW1iZXJcbiAgbGV0IG9yaWdZOiBudW1iZXJcbiAgbGV0IHN0YXJ0Q2xpZW50WDogbnVtYmVyXG4gIGxldCBzdGFydENsaWVudFk6IG51bWJlclxuICBsZXQgc3RhcnRTY2FsZTogbnVtYmVyXG4gIGxldCBzdGFydERpc3RhbmNlOiBudW1iZXJcbiAgY29uc3QgcG9pbnRlcnM6IFBvaW50ZXJFdmVudFtdID0gW11cblxuICBmdW5jdGlvbiBoYW5kbGVEb3duKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAvLyBEb24ndCBoYW5kbGUgdGhpcyBldmVudCBpZiB0aGUgdGFyZ2V0IGlzIGV4Y2x1ZGVkXG4gICAgaWYgKGlzRXhjbHVkZWQoZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnQsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgYWRkUG9pbnRlcihwb2ludGVycywgZXZlbnQpXG4gICAgaXNQYW5uaW5nID0gdHJ1ZVxuICAgIG9wdGlvbnMuaGFuZGxlU3RhcnRFdmVudChldmVudClcbiAgICBvcmlnWCA9IHhcbiAgICBvcmlnWSA9IHlcblxuICAgIHRyaWdnZXIoJ3Bhbnpvb21zdGFydCcsIHsgeCwgeSwgc2NhbGUgfSwgb3B0aW9ucylcblxuICAgIC8vIFRoaXMgd29ya3Mgd2hldGhlciB0aGVyZSBhcmUgbXVsdGlwbGVcbiAgICAvLyBwb2ludGVycyBvciBub3RcbiAgICBjb25zdCBwb2ludCA9IGdldE1pZGRsZShwb2ludGVycylcbiAgICBzdGFydENsaWVudFggPSBwb2ludC5jbGllbnRYXG4gICAgc3RhcnRDbGllbnRZID0gcG9pbnQuY2xpZW50WVxuICAgIHN0YXJ0U2NhbGUgPSBzY2FsZVxuICAgIHN0YXJ0RGlzdGFuY2UgPSBnZXREaXN0YW5jZShwb2ludGVycylcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmUoZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgIGlmIChcbiAgICAgICFpc1Bhbm5pbmcgfHxcbiAgICAgIG9yaWdYID09PSB1bmRlZmluZWQgfHxcbiAgICAgIG9yaWdZID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHN0YXJ0Q2xpZW50WCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBzdGFydENsaWVudFkgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGFkZFBvaW50ZXIocG9pbnRlcnMsIGV2ZW50KVxuICAgIGNvbnN0IGN1cnJlbnQgPSBnZXRNaWRkbGUocG9pbnRlcnMpXG4gICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFVzZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZmlyc3QgMiBwb2ludGVyc1xuICAgICAgLy8gdG8gZGV0ZXJtaW5lIHRoZSBjdXJyZW50IHNjYWxlXG4gICAgICBjb25zdCBkaWZmID0gZ2V0RGlzdGFuY2UocG9pbnRlcnMpIC0gc3RhcnREaXN0YW5jZVxuICAgICAgY29uc3QgdG9TY2FsZSA9IGNvbnN0cmFpblNjYWxlKChkaWZmICogb3B0aW9ucy5zdGVwKSAvIDgwICsgc3RhcnRTY2FsZSkuc2NhbGVcbiAgICAgIHpvb21Ub1BvaW50KHRvU2NhbGUsIGN1cnJlbnQpXG4gICAgfVxuXG4gICAgcGFuKFxuICAgICAgb3JpZ1ggKyAoY3VycmVudC5jbGllbnRYIC0gc3RhcnRDbGllbnRYKSAvIHNjYWxlLFxuICAgICAgb3JpZ1kgKyAoY3VycmVudC5jbGllbnRZIC0gc3RhcnRDbGllbnRZKSAvIHNjYWxlLFxuICAgICAge1xuICAgICAgICBhbmltYXRlOiBmYWxzZVxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVVwKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAvLyBEb24ndCBjYWxsIHBhbnpvb21lbmQgd2hlbiBwYW5uaW5nIHdpdGggMiB0b3VjaGVzXG4gICAgLy8gdW50aWwgYm90aCB0b3VjaGVzIGVuZFxuICAgIGlmIChwb2ludGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRyaWdnZXIoJ3Bhbnpvb21lbmQnLCB7IHgsIHksIHNjYWxlIH0sIG9wdGlvbnMpXG4gICAgfVxuICAgIC8vIE5vdGU6IGRvbid0IHJlbW92ZSBhbGwgcG9pbnRlcnNcbiAgICAvLyBDYW4gcmVzdGFydCB3aXRob3V0IGhhdmluZyB0byByZWluaXRpYXRlIGFsbCBvZiB0aGVtXG4gICAgLy8gUmVtb3ZlIHRoZSBwb2ludGVyIHJlZ2FyZGxlc3Mgb2YgdGhlIGlzUGFubmluZyBzdGF0ZVxuICAgIHJlbW92ZVBvaW50ZXIocG9pbnRlcnMsIGV2ZW50KVxuICAgIGlmICghaXNQYW5uaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaXNQYW5uaW5nID0gZmFsc2VcbiAgICBvcmlnWCA9IG9yaWdZID0gc3RhcnRDbGllbnRYID0gc3RhcnRDbGllbnRZID0gdW5kZWZpbmVkXG4gIH1cblxuICBmdW5jdGlvbiBiaW5kKCkge1xuICAgIG9uUG9pbnRlcignZG93bicsIGVsZW0sIGhhbmRsZURvd24pXG4gICAgb25Qb2ludGVyKCdtb3ZlJywgZG9jdW1lbnQsIG1vdmUsIHsgcGFzc2l2ZTogdHJ1ZSB9KVxuICAgIG9uUG9pbnRlcigndXAnLCBkb2N1bWVudCwgaGFuZGxlVXAsIHsgcGFzc2l2ZTogdHJ1ZSB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBkZXN0cm95UG9pbnRlcignZG93bicsIGVsZW0sIGhhbmRsZURvd24pXG4gICAgZGVzdHJveVBvaW50ZXIoJ21vdmUnLCBkb2N1bWVudCwgbW92ZSlcbiAgICBkZXN0cm95UG9pbnRlcigndXAnLCBkb2N1bWVudCwgaGFuZGxlVXApXG4gIH1cblxuICBpZiAoIW9wdGlvbnMuZGlzYWJsZVBhbikge1xuICAgIGJpbmQoKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95LFxuICAgIGdldFBhbjogKCkgPT4gKHsgeCwgeSB9KSxcbiAgICBnZXRTY2FsZTogKCkgPT4gc2NhbGUsXG4gICAgZ2V0T3B0aW9uczogKCkgPT4gc2hhbGxvd0Nsb25lKG9wdGlvbnMpLFxuICAgIHBhbixcbiAgICByZXNldCxcbiAgICBzZXRPcHRpb25zLFxuICAgIHNldFN0eWxlOiAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBzZXRTdHlsZShlbGVtLCBuYW1lLCB2YWx1ZSksXG4gICAgem9vbSxcbiAgICB6b29tSW4sXG4gICAgem9vbU91dCxcbiAgICB6b29tVG9Qb2ludCxcbiAgICB6b29tV2l0aFdoZWVsXG4gIH1cbn1cblxuUGFuem9vbS5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zXG5cbmV4cG9ydCBkZWZhdWx0IFBhbnpvb21cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n"
    )
  },
  ,
  function(module, __webpack_exports__, __webpack_require__) {
    'use strict'
    eval(
      "__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_panzoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n\r\nconsole.log('This is a demo version of Panzoom for testing.');\r\nconsole.log('It exposes a global (window.Panzoom) and should not be used in production.');\r\nwindow.Panzoom = _src_panzoom__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"];\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kZW1vL2dsb2JhbC1wYW56b29tLnRzPzdiODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFvQztBQUVwQyxPQUFPLENBQUMsR0FBRyxDQUFDLGdEQUFnRCxDQUFDO0FBQzdELE9BQU8sQ0FBQyxHQUFHLENBQUMsNEVBQTRFLENBQUM7QUFPekYsTUFBTSxDQUFDLE9BQU8sR0FBRyw0REFBTyIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhbnpvb20gZnJvbSAnLi4vc3JjL3Bhbnpvb20nXG5cbmNvbnNvbGUubG9nKCdUaGlzIGlzIGEgZGVtbyB2ZXJzaW9uIG9mIFBhbnpvb20gZm9yIHRlc3RpbmcuJylcbmNvbnNvbGUubG9nKCdJdCBleHBvc2VzIGEgZ2xvYmFsICh3aW5kb3cuUGFuem9vbSkgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uLicpXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgUGFuem9vbTogdHlwZW9mIFBhbnpvb21cbiAgfVxufVxud2luZG93LlBhbnpvb20gPSBQYW56b29tXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n"
    )
  },
  function(module, exports) {
    eval(
      "/* eslint-disable no-var */\n// Support: IE11 only\nif (window.NodeList && !NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach\n}\n// Support: IE11 only\n// CustomEvent is an object instead of a constructor\nif (typeof window.CustomEvent !== 'function') {\n  window.CustomEvent = function CustomEvent(event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null }\n    var evt = document.createEvent('CustomEvent')\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail)\n    return evt\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcG9seWZpbGxzLmpzPzA2NzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuLy8gU3VwcG9ydDogSUUxMSBvbmx5XG5pZiAod2luZG93Lk5vZGVMaXN0ICYmICFOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xuICBOb2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoXG59XG4vLyBTdXBwb3J0OiBJRTExIG9ubHlcbi8vIEN1c3RvbUV2ZW50IGlzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgY29uc3RydWN0b3JcbmlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gIHdpbmRvdy5DdXN0b21FdmVudCA9IGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogbnVsbCB9XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpXG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKVxuICAgIHJldHVybiBldnRcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n"
    )
  }
])
